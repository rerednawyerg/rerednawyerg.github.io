module constructor
	Class1.smethod_22()
		enter while loop
			Class1.smethod_20()
				RSACryptoServiceProvider.UseMachineKeyStore = true;
			enumerator = Process.GetCurrentProcess().Modules.GetEnumerator();
				- gets the modules which have been loaded by the current process, creates an enumerator for them
			Iterate through the modules until "clrjit.dll" is found
				- creates Version string v - "4.0.30319.0"
				- creates version strings v2 and v3 - "4.0.30319.17020" and "4.0.30319.17921"
			GetManifestResourceStream - "O5N0AlYCaWVNsnW9dJ.CHsx1XBDMSVKvegAep"
				- open as binary reader
			Read bytes into array19
			Create array of 32 bytes 
				go through case statement and set bytes of array manually
			set array13 to equal array
			create array2 - array of 16 bytes
				go through case staetmenet and set bytes manually
			assign array2 to array7
			reverse array7
			set array8 to public key token of the assembly
				can do something else if it is set, but it is null
			XOR the first 16 bytes of array13 with corresponding bytes of array7
			set array18 equal to array19
			array17 is a new array of array18.length
			goes through a loop and uses calculations to add bytes to array17 four byte at a time using array7 and array13
			set array14 to equal array17
			set array12 to equal array14
			set ptr to equal array12[0]
			xor every other set of 4 bytes of array12 with 572540235L
			eP70mcl5YqYlM8NHyjj = new BinaryReader(new MemoryStream(array14));  -- array12 and 14 are the same
			set the stream reader position to 0
			get the modules of the assembly, and grab the instance handle of the base assembly, convert to Int64
			checks the location value of the current assembly - @"C:\Users\themo\Desktop\helper.exe"
			advance the streamreader 4 bytes
			advance the streamreader 4 bytes
			advance the streamreader 4 bytes
			advance the streamreader 4 bytes
			read 4 bytes into num52 and advance the streamreader 4 bytes
			check if num52 == 4
			check if num52 == 1
			do this on a loop a bunch of times
				intptr2 is a pointer to a position in the binary reader - eP70mcl5YqYlM8NHyjj
				loadlibrary("kernel32.dll").getprocaddress("virtualprotect") assign delegate to ujVDNaeA9qo04LyS9DL.eaUliLRA0J
				call virtualprotect(intptr2, 4, 4, ref u2)  -- allow write
					- write something to the location
				call virtualprotect(intptr2, 4, u2, ref u2) -- change back to just reading
				
			-- I created dummp called streamreader.bin with contents here
			
			create a hashtable using the streamreader, argument to newhashtable is (current 4 bytes of the streamreader + 1) -- will be capacity of the hashtable
				bO0l3NaAiy is name
			
			create a struct nwk7nAlIJStV9Jvx51H2 
				nwk7nAlIJStV9Jvx51H2.D8wl1IyPdO to 42  - byte array
				nwk7nAlIJStV9Jvx51H2.AoWltiW0L7 = false
			add (0L, nwk7nAlIJStV9Jvx51H2) to hashtable
			if binaryreader position is less than binaryreader.size minus 1, then jump somewhere
				at stream position 0x1400, length of stream is 0x428E5
			
			read 0x6B3 bytes into byte array d8wl1IyPdO
			-- I created dump called d8wl1IyPdO.bin
			create struct Nwk7nAlIJStV9Jvx51H
			struct now holds the most recent dump d8wl1IyPdO
				also holds the value false in the other variable
			add (0x0000000000AD2260, Nwk7nAlIJStV9Jvx51H) to the hashtable -- value:struct
				position 0x1abf, length of stream is 0x428E5 
				
			read 0x000002A2 bytes into byte array d8wl1IyPdO
			-- I created dump called d8wl1IyPdO_2.bin
			create struct Nwk7nAlIJStV9Jvx51H
			struct now holds the most recent dump d8wl1IyPdO
				also holds the value false in the other variable
			add (0x0000000000AD22D4, Nwk7nAlIJStV9Jvx51H) to the hashtable -- value:struct
				position 0x1d6d, length of stream is 0x428E5 
			 
			 do this a bunch
			 set int ptr3
			 set array3 equal to 12 empty bytes
				manually fill it with bytes, get string variable "mscorjit.dll" returned in utf8
			
			set array3 to 10 bytes 
				manually fill with bytes that make string "clrjit.dll"
			
			intptr5 = LoadLibrary("clrjit.dll")
			array6 is 6 byte array - "getJit"
			invokes getJit - returns as a pointer
			do some stuff I couldn't follow with intPtrs
			get the current process
				create an enumerator of the modules loaded by the process
				loop through until processModule == "clrjit.dll"
					get baseaddress of clrjit.dll -- set to intptr3
					check for something, not sure
			
			get type System.Reflection.RuntimeModule
			bunch of stuff
			eventually call virtual alloc
			call virtual protect a few times
			annoyed, not really sure what this function does
		
		Create AES key and IV, decrypt resource -- E32BvKlUARKG2Wec5C.R1WtgOOCLGWOD0JgIt
		Key: 80 66 e4 f3 20 64 e1 16 3a f7 09 a7 68 3f 5c 63 c5 9b ea 27 02 6b 2f aa 7a 19 97 e2 f6 8f c8 d1 
		IV: 53 ec 10 9b ea 73 04 a9 ec 03 67 41 03 0d 60 a6
		<RSAKeyValue><Modulus>zlUkMywGKDNbeJxH/zDotBK2KGsq3+fCyOXuaEHc38tL8CEymadHC4IvnPJ4ZHsuEIho1JVEVlJXYmPAkmiAboHJvV8Wnei2yfvn6tWX/Cnz7brgK+XlQVtVXlGUfU/ygy3kahGh10KW3yBgqs8Nuz7UlYBB7QLjBzyjFFy4chM=</Modulus><Exponent>AQAB</Exponent></RSAKeyValue>
		use it to verify the SHA1 hash of the current running binary
			FileStream fileStream = new FileStream(@"C:\Users\themo\Desktop\helper.exe", FileMode.Open, FileAccess.Read, FileShare.Read);
			read 0x152 bytes from file stream into an array7
		read 0x60 bytes into array7
		Verifies the hash of various sections of the code
			
	method
		checks if debugger is attached
	
entry point
			
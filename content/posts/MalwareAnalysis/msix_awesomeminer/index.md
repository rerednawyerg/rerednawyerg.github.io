---
title: "MSIX AwesomeMiner"
date: 2023-03-16T08:27:19-05:00
draft: false
---

---
{{< pswp-init >}}

As has been widely reported in the security industry, Google searches resulting in malicious ads were incredibly prolific during late 2022 and early 2023. This activity has reduced significantly in recent weeks, but it isn't quite dead yet. 


A search for "Awesome Miner" resulted in a suspicious advertisement displaying above the legitimate Awesome Miner site. 
{{< figure src="images/google_search.png" alt="google_search" position="center" >}}

On clicking the ad, a check is performed to examine the user agent, IP address, and http referrer. If any of the checks fail, (non-Windows user agent, VPS IP range, etc.), the user is directed to `https://jacobswoodworks.com`, which appears to be a legitimate woodworking site.  

If all the checks pass, the user is redirected to `https://awesomeminer.shop/install-download.html`, where they are presented with the following page.
{{< figure src="images/awesomeminer_shop.png" alt="awesomeminer_shop" position="center" >}}

When the download button is clicked, a request is made to `https://always-trouble.ru/1awesome.php?site=awesome`, which grabs the initial payload from `https://cdn-dwn.com/Awesome Miner-x64.msix`.

I've never worked with a `.msix` file before, let's see what we can uncover!

## Stage One: Awesome Miner-x64.msix 

According to the Microsoft documentation, MSIX is "a Windows app package format that combines the best features of MSI, .appx, App-V, and ClickOnce to provide a modern and reliable packaging experience."  

An interesting feature is that MSIX can be used to package existing Windows apps, and use something called the [Package Support Framework](https://learn.microsoft.com/en-us/windows/msix/psf/package-support-framework-overview) to "apply fixes to existing desktop apps when you don't have access to the source code." 

MSIX files can be unzipped to view their contents, below is what I was initially presented with.
{{< figure src="images/msix_directory.png" alt="msix_directory" position="center" >}}

The first thing I did was check the hashes of the files starting with "AwesomeMiner" -- they are all signed by `IntelliBreeze Software AB`, a Swedish company who creates the real Awesome Miner tool. 
Using dynamic analysis, on double clicking the .msix file, a wizard is displayed which walks the user through the installation of Awesome Miner.  

My suspicion is the threat actor used MSIX to repackage a copy of the Awesome Miner tool and then added some malicious capabilities.
{{< figure src="images/installer.png" alt="installer" position="center" >}}
#### AppxManifest.xml
My next task is to figure out what malicious activities have been added to the installer. I started by taking a look at the `AppxManifest.xml` file. Turning again to the docs, it is "an XML document that contains the info the system needs to deploy, display, or update a Windows app"
{{< figure src="images/appxmanifest_first.png" alt="appxmanifest_first" position="center" >}}
Breaking down the first section of the XML manifest - The language listed is Russian, which indicates it is possible this was created on a device with Russian set as the system language -- but this could very easily have been edited in the manifest after creation. 

The capabilities here are of interest, they allow the application to install "one or more Local System services along with the app".

Lastly, the publisher of the app is `Ashana Global LTD`, a company which is also the signer of the .msix file.
{{< figure src="images/signer.png" alt="signer" position="center" >}}
Moving on to the next section of the manifest, the application definitions. 
{{< figure src="images/appxmanifest_second.png" alt="appxmanifest_second" position="center" >}}
The first application listed is the AwesomeMiner.exe I verified previously; the "AI_STUBS\AistubX64.exe" is a helper process which copies the application's data from the Virtual File System (VFS) folder inside the package to the local storage of the packaged version. 

The next application is where things start to get interesting. The Id is "HostedService", and the executable path points to `VFS\AppDat\Zhelper.exe`. On line 55, "desktop6:Service", we can see that this executable will be installed as an auto-startup service running with Local System privileges. 

Note: There are a few Russian words in the second application's fields which translate to "Description_of_your_service" and "Your_service". This again points to the possibility that this MSIX file was created on a device with Russian as the system language.

Before we move on to investigating the `Zhelper.exe` file, there is one more item from the MSIX folder we must investigate.
#### config.json
As you may have noticed from the prior screenshot of the MSIX folder, one of the files it contained was called "config.json". After some Googling around, I discovered the MSIX Package Support Framework (PSF) has a [feature](https://learn.microsoft.com/en-us/windows/msix/psf/run-scripts-with-package-support-framework) which allows a PowerShell script to be run before and after a packaged application executable runs. 

All that is needed for this functionality is to make some edits to the "config.json" file required by PSF. 
{{< figure src="images/config_json.png" alt="config_json" position="center" >}}
The "id" field indicates a packaged application executable, and "startScript" or "endScript" determines whether the script will be run prior or post execution. The script path points to the location of the PowerShell script, which in this case is located in the same directory with the name "new msix.ps1".

So, this script will be run twice, once before the Awesome Miner executable and once before "Zhelper.exe".
#### PowerShell Script
Below are the contents of the PowerShell script "new msix.ps1".
{{< figure src="images/powershell_msix.png" alt="powershell_msix" position="center" >}}
Breaking it down -- first a request is made to `https://always-trouble.ru/start.php`, and since there is no response gathered, I am guessing this is to indicate to the threat actor that a victim has opened the MSIX file.  

Then, a .NET binary is downloaded from `http://62.204.41.169/helper.exe`. We know it is .NET, since in the next line `[System.Reflection.Assembly]::Load` is used to reflectively load the assembly into memory. 

Once the binary has been loaded into memory, the script attempts to identify the entry point, and if it is successful, invokes it.

Next, a RAR archive is downloaded from `http://7zip-one.software/Zeip.rar` and saved into the AppData folder. 

Line 15 is a little tricky - it executes 7z.exe from the user's AppData folder and uses it to extract a DLL from the archive. But how did 7z.exe get there?   

Previously I mentioned the Virtual File System feature of MSIX; a little more about it [here](https://techcommunity.microsoft.com/t5/modern-work-app-consult-blog/msix-how-to-copy-data-outside-the-installation-folder-during-the/ba-p/1133602) -- "..gives the possibility to map the most common folders inside a special folder called VFS. When the application looks for a file inside these folders, Windows will redirect the call to the VFS folder."
{{< figure src="images/vfs_appdata.png" alt="vfs_appdata" position="center" >}}
It turns out, the threat actor had included 7zip in the VFS folder, so if the blog is accurate, the request in PowerShell should redirect here. 

Once the DLL is extracted, it is registered using rundll32. Then a final web request is made to `https://always-trouble.ru/install.php` -- likely to inform the threat actor the installation is complete.

#### Next Steps
Now I need to decide which malicious binary to investigate first. So far I've determined the order of execution when installing the MSIX package is: 
```String
PowerShell script -> helper.exe -> Zeip.dll -> Zhelper.exe
```
I've already broken down the PS script, so on to helper.exe.

## Stage 2: Helper.exe
As I previously determined, helper.exe was written using the .NET framework, so I can inspect it in dnSpy.
{{< figure src="images/dotnet_reactor.png" alt="dotnet_reactor" position="center" >}}
By checking out the `<Module>` class, I found the binary was obfuscated using `.NET Reactor`, which is supported by de4dot, the .NET deobfuscation tool. 
```bash
de4dot.exe helper.exe -p dr4
```
This command ran successfully, but when trying to debug the program in dnSpy, an unknown exception was thrown. The cleaned version from de4dot must be broken somehow.  

When digging in a little more on the obfuscated version, I found that unfortunately this binary is a little beyond my skill. I wasn't able to deobfuscate it enough to understand what was going on, and trying to debug the original version was very difficult to follow. I won't be able to do as deep a dive as I'd like.  
#### Dynamic Analysis
